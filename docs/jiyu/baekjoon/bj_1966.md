# [백준 1966번] 프린터 큐

> 자료구조(큐)

## 📋 문제

여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다.  
여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다.  
하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.

1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.

예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다.  
예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

## 👉 입력

첫 줄에 테스트케이스의 수가 주어진다.  
각 테스트케이스는 두 줄로 이루어져 있다.

테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다.  
이때 맨 왼쪽은 0번째라고 하자.  
두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다.  
중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

## 👈 출력

각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

**예제1**

```
Input:
3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1

Output:
1
2
5
```

## 📝 풀이

```python
import sys
from collections import deque
input = sys.stdin.readline

def printer(n, m, priority):
  q = deque(priority)
  count = 0

  while True:
    maxNum = max(q)
    temp = q.popleft()
    m -= 1

    if maxNum == temp:
      count += 1
      if m < 0:
        return count
    else:
      q.append(temp)
      if m < 0:
        m = len(q) - 1

testcase = int(input())
for _ in range(testcase):
  n, m = map(int, input().split())
  priority = list(map(int, input().split()))
  print(printer(n, m, priority))
```

입력이 좀 까다롭게 생긴 문제였다.

```
3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1
```

입력이 이러한 형식으로 들어오는데 이때 3은 테스트 케이스의 수이다.  
그리고 그 다음줄부터 첫 번째 줄에 n과 m, 두 번째 줄에 n개 문서의 중요도가 주어지는 것이다.

따라서 테스트케이스의 수는 testcase에 저장했고 for문으로 testcase들을 하나씩 살펴본다.  
n, m, priority를 입력받았다면 printer 함수에 인자로 넘겨준다.

printer 함수에서는 n개 문서의 중요도를 저장한 priority를 큐로 바꿔준다.  
그리고 몇 번째로 인쇄되었는지 궁금한 문서가 인쇄될 때까지 큐를 살펴본다.

while문으로 무한루프를 돌며 먼저 현재 큐에서 제일 우선순위가 높은 것을 maxNum에 저장한다.  
그리고 큐의 제일 앞에 있는 것을 temp에 저장한다.  
문서를 하나 뺐기 때문에 m을 1 감소시킨다.

이후 maxNum이 temp와 같은지 비교한다.  
이는 우선순위가 제일 높은 것이 인쇄될 차례인지 확인하는 것이다.  
이 경우에 해당한다면 문서 하나가 인쇄될 예정이므로 count를 1 증가시킨다.  
그리고 만약 m이 0보다 작다면 몇 번째로 인쇄되었는지 궁금한 문서가 큐의 제일 앞에 있었다는 뜻이므로 count를 리턴한다.

maxNum이 temp와 같지 않다면 지금 이 문서보다 우선순위가 높은 문서가 큐 안에 존재한다는 뜻이다.  
따라서 해당 문서를 다시 큐에 넣어준다.  
이때 문서가 우리가 살펴보고자 하는 문서라면 다시 m을 조정해 문서의 위치를 알려준다.
