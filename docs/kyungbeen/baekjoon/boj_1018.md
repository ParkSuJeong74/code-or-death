[KyungBeen](../README.md)

# 1018번 체스판 다시 칠하기

## Input

첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.
<br/><br/>

## Output

첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.
<br/><br/>

## Explanation

- 흰색칸 또는 검은색칸으로 시작하는 8\*8 list를 선언.

- 4중 for문 => 바깥 2중 for문은 8\*8의 인덱스를, 안쪽 2중 for문은 입력한 보드의 8\*8의 index를 가져옴.

- 가져온 index를 이용해 8칸씩 비교하며 기 선언된 list와 다른 칸을 count하면서 최소 count를 저장(다시 칠해야 하는 칸의 최솟값)

- 8\*8씩 2중리스트로 접근해야 하나? 반복을 두 번 돌아야 하나? 등의 생각이 들어 뭔가 어렵게 느껴졌다. 무식하게 구현했지만 solve 후에 보니 복잡한 듯 보여도 간단한 로직.

  <br/><br/>

## Code

```
import sys
from collections import deque

n, m = map(int, sys.stdin.readline().split())
board = list(sys.stdin.readline().strip() for _ in range(n))
w_start = ['WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW']
b_start = ['BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB',
           'BWBWBWBW',
           'WBWBWBWB']
check_min = 64
check_w = 0
check_b = 0

for i in range(n-7):
    for j in range(m-7):
        check_w = 0
        check_b = 0
        for x in range(i, i+8):
            for y in range(j, j+8):
                if board[x][y] != w_start[x-i][y-j]:
                    check_w += 1
                if board[x][y] != b_start[x-i][y-j]:
                    check_b += 1
        check_min = min(check_min, min(check_w, check_b))

print(check_min)
```
